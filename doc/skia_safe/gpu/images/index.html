<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `images` mod in crate `skia_safe`."><title>skia_safe::gpu::images - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="skia_safe" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0 (5680fa18f 2023-08-23)" data-channel="1.72.0" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../../../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../skia_safe/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../skia_safe/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module images</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">skia_safe</a>::<wbr><a href="../index.html">gpu</a>::<wbr><a class="mod" href="#">images</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/skia_safe/gpu/ganesh/image_ganesh.rs.html#1-310">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.adopt_texture_from.html" title="fn skia_safe::gpu::images::adopt_texture_from">adopt_texture_from</a></div><div class="desc docblock-short">Creates GPU-backed <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> from <code>backend_texture</code> associated with context.
Skia will assume ownership of the resource and will release it when no longer needed.
A non-null <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> is returned if format of <code>backend_texture</code> is recognized and supported.
Recognized formats vary by GPU backend.</div></li><li><div class="item-name"><a class="fn" href="fn.borrow_texture_from.html" title="fn skia_safe::gpu::images::borrow_texture_from">borrow_texture_from</a></div><div class="desc docblock-short">Creates GPU-backed <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> from the provided GPU texture associated with context.
GPU texture must stay valid and unchanged until <code>texture_release_proc</code> is called by Skia.
Skia will call <code>texture_release_proc</code> with the passed-in <code>release_context</code> when <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a>
is deleted or no longer refers to the texture.
A non-null <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> is returned if format of <code>backend_texture</code> is recognized and supported.
Recognized formats vary by GPU backend.
Note: When using a DDL recording context, <code>texture_release_proc</code> will be called on the
GPU thread after the DDL is played back on the direct context.</div></li><li><div class="item-name"><a class="fn" href="fn.cross_context_texture_from_pixmap.html" title="fn skia_safe::gpu::images::cross_context_texture_from_pixmap">cross_context_texture_from_pixmap</a></div><div class="desc docblock-short">Creates a GPU-backed <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> from pixmap. It is uploaded to GPU backend using context.
Created <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> is available to other GPU contexts, and is available across thread
boundaries. All contexts must be in the same GPU share group, or otherwise
share resources.
When <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> is no longer referenced, context releases texture memory
asynchronously.
<a href="../../type.ColorSpace.html" title="type skia_safe::ColorSpace"><code>ColorSpace</code></a> of <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> is determined by <code>pixmap.color_space()</code>.
<a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> is returned referring to GPU backend if context is not <code>None</code>,
format of data is recognized and supported, and if context supports moving
resources between contexts. Otherwise, pixmap pixel data is copied and <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a>
as returned in raster format if possible; <code>None</code> may be returned.
Recognized GPU formats vary by platform and GPU backend.</div></li><li><div class="item-name"><a class="fn" href="fn.get_backend_texture_from_image.html" title="fn skia_safe::gpu::images::get_backend_texture_from_image">get_backend_texture_from_image</a></div><div class="desc docblock-short">Retrieves the existing backend texture. If <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> is not a Ganesh-backend texture image
or otherwise does not have such a texture, <code>false</code> is returned. Otherwise, returned will
be set to the image’s texture.</div></li><li><div class="item-name"><a class="fn" href="fn.subset_texture_from.html" title="fn skia_safe::gpu::images::subset_texture_from">subset_texture_from</a></div><div class="desc docblock-short">Returns subset of this image as a texture-backed image.</div></li><li><div class="item-name"><a class="fn" href="fn.texture_from_compressed_texture_data.html" title="fn skia_safe::gpu::images::texture_from_compressed_texture_data">texture_from_compressed_texture_data</a></div><div class="desc docblock-short">Creates a GPU-backed <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> from compressed data.
This method will return an <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> representing the compressed data.
If the GPU doesn’t support the specified compression method, the data
will be decompressed and then wrapped in a GPU-backed image.
Note: one can query the supported compression formats via
<a href="../../struct.RCHandle.html#method.compressed_backend_format" title="method skia_safe::RCHandle::compressed_backend_format"><code>RecordingContext::compressed_backend_format</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.texture_from_image.html" title="fn skia_safe::gpu::images::texture_from_image">texture_from_image</a></div><div class="desc docblock-short">Returns <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> backed by GPU texture associated with context. Returned <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> is
compatible with <a href="../../surface/type.Surface.html" title="type skia_safe::surface::Surface"><code>Surface</code></a> created with <code>dst_color_space</code>. The returned <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> respects
mipmapped setting; if mipmapped equals <a href="../enum.MipMapped.html#variant.Yes" title="variant skia_safe::gpu::MipMapped::Yes"><code>Mipmapped::Yes</code></a>, the backing texture
allocates mip map levels.
The mipmapped parameter is effectively treated as <code>No</code> if MIP maps are not supported by the
GPU.
Returns original <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> if the image is already texture-backed, the context matches, and
mipmapped is compatible with the backing GPU texture. skgpu::Budgeted is ignored in this
case.
Returns <code>None</code> if context is <code>None</code>, or if <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> was created with another
<a href="../type.DirectContext.html" title="type skia_safe::gpu::DirectContext"><code>DirectContext</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.texture_from_yuva_pixmaps.html" title="fn skia_safe::gpu::images::texture_from_yuva_pixmaps">texture_from_yuva_pixmaps</a></div><div class="desc docblock-short">Creates a GPU-backed <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> from <a href="../../yuva_pixmaps/type.YUVAPixmaps.html" title="type skia_safe::yuva_pixmaps::YUVAPixmaps"><code>YUVAPixmaps</code></a>.
The image will remain planar with each plane converted to a texture using the passed
<a href="../type.RecordingContext.html" title="type skia_safe::gpu::RecordingContext"><code>RecordingContext</code></a>.
<a href="../../yuva_pixmaps/type.YUVAPixmaps.html" title="type skia_safe::yuva_pixmaps::YUVAPixmaps"><code>YUVAPixmaps</code></a> has a <a href="../../yuva_info/type.YUVAInfo.html" title="type skia_safe::yuva_info::YUVAInfo"><code>YUVAInfo</code></a> which specifies the transformation from YUV to RGB.
The <a href="../../type.ColorSpace.html" title="type skia_safe::ColorSpace"><code>ColorSpace</code></a> of the resulting RGB values is specified by <code>image_color_space</code>. This will
be the <a href="../../type.ColorSpace.html" title="type skia_safe::ColorSpace"><code>ColorSpace</code></a> reported by the image and when drawn the RGB values will be converted
from this space into the destination space (if the destination is tagged).
Currently, this is only supported using the GPU backend and will fail if context is <code>None</code>.
<a href="../../yuva_pixmaps/type.YUVAPixmaps.html" title="type skia_safe::yuva_pixmaps::YUVAPixmaps"><code>YUVAPixmaps</code></a> does not need to remain valid after this returns.</div></li><li><div class="item-name"><a class="fn" href="fn.texture_from_yuva_textures.html" title="fn skia_safe::gpu::images::texture_from_yuva_textures">texture_from_yuva_textures</a></div><div class="desc docblock-short">Creates a GPU-backed <a href="../../image/type.Image.html" title="type skia_safe::image::Image"><code>Image</code></a> from <code>YUV[A]</code> planar textures. This requires that the textures
stay valid for the lifetime of the image. The ReleaseContext can be used to know when it is
safe to either delete or overwrite the textures. If ReleaseProc is provided it is also called
before return on failure.</div></li></ul></section></div></main></body></html>